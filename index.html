<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>All-in-One QR Generator, Scanner, Background Remover & Image Compressor</title>
  <meta name="description" content="Free online tools for QR code generation, QR scanning, background removal, and image compression. Works instantly in the browser with no signup." />
  <meta name="keywords" content="QR code generator, QR scanner, remove background, image compressor, free online tools" />
  <meta property="og:title" content="All-in-One QR & Image Toolkit" />
  <meta property="og:description" content="Generate QR codes, scan codes, remove image backgrounds, and compress images online ‚Äî all in one place." />
  <meta property="og:image" content="https://yourdomain.com/preview.png" />
  <meta property="og:url" content="https://yourdomain.com" />
  <meta name="twitter:card" content="summary_large_image" />

  <!-- JSON-LD Schema for WebApplication -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "All-in-One QR & Image Toolkit",
    "url": "https://yourdomain.com",
    "description": "Free online QR generator, scanner, background remover, and image compressor.",
    "applicationCategory": "Utility",
    "operatingSystem": "All"
  }
  </script>

  <!-- Google Analytics 4 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-JDSMMSJ15R"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-JDSMMSJ15R');
  </script>

  <!-- AdSense (replace ca-pub-########### below when approved) -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1909319391447068" crossorigin="anonymous"></script>

  <script>
    (() => {
      try {
        const stored = localStorage.getItem('aoi-theme');
        const prefersDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)').matches : false;
        const theme = stored || (prefersDark ? 'dark' : 'light');
        document.documentElement.dataset.theme = theme;
      } catch (err) {
        document.documentElement.dataset.theme = 'light';
      }
    })();
  </script>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light;
      --bg: #f4f7fb;
      --surface: #ffffff;
      --surface-soft: #f8fafc;
      --border: rgba(15, 23, 42, 0.08);
      --muted: #475569;
      --text: #0f172a;
      --accent: #0ea5e9;
      --accent-strong: #0284c7;
      --shadow: 0 28px 48px rgba(15, 23, 42, 0.08);
      --radius-xl: 1.5rem;
    }
    :root[data-theme="dark"] {
      color-scheme: dark;
      --bg: #0b1220;
      --surface: #111827;
      --surface-soft: rgba(30, 41, 59, 0.65);
      --border: rgba(148, 163, 184, 0.22);
      --muted: #94a3b8;
      --text: #e2e8f0;
      --accent: #22d3ee;
      --accent-strong: #0ea5e9;
      --shadow: 0 32px 60px rgba(2, 6, 23, 0.55);
    }
    body {
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      transition: background 0.3s ease, color 0.3s ease;
    }
    a { color: inherit; }
    .glass {
      background: var(--surface);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    .tab-btn {
      border-radius: 1rem;
      padding: 0.75rem 1rem;
      font-weight: 600;
      color: var(--muted);
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, border 0.2s ease;
      border: 1px solid transparent;
      width: 100%;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      text-align: center;
    }
    .tab-btn:hover {
      color: var(--text);
      background: var(--surface-soft);
    }
    .tab-active {
      background: var(--surface-soft);
      color: var(--text);
      border-color: var(--border);
      box-shadow: 0 14px 28px rgba(15, 23, 42, 0.08);
    }
    :root[data-theme="dark"] .tab-active {
      box-shadow: 0 18px 30px rgba(2, 6, 23, 0.55);
    }
    .panel { align-content: flex-start; }
    .section-heading {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 1rem;
    }
    .text-muted { color: var(--muted); }
    .quick-action {
      border: 1px solid var(--border);
      background: var(--surface-soft);
      color: var(--text);
      border-radius: 0.75rem;
      font-weight: 500;
      padding: 0.4rem 0.75rem;
      transition: background 0.2s ease, border 0.2s ease, color 0.2s ease;
      cursor: pointer;
    }
    .quick-action:hover {
      background: var(--surface);
      border-color: var(--accent);
      color: var(--accent-strong);
    }
    .form-field {
      width: 100%;
      background: var(--surface-soft);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 0.85rem;
      padding: 0.7rem 0.85rem;
      transition: border 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .form-field:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.25);
      background: var(--surface);
    }
    .form-field[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }
    input[type="color"].form-field { padding: 0.2rem; height: 44px; }
    input[type="file"].form-field { padding: 0.5rem 0.85rem; }
    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    .btn {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 0.4rem;
      border-radius: 0.85rem;
      font-weight: 600;
      padding: 0.65rem 1.1rem;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
      cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }
    .btn-primary {
      background: var(--accent-strong);
      color: #fff;
      box-shadow: 0 12px 24px rgba(14, 165, 233, 0.25);
    }
    .btn-primary:hover { background: var(--accent); }
    .btn-secondary {
      background: var(--surface-soft);
      color: var(--text);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover { background: var(--surface); }
    .btn-ghost {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
    }
    .btn-ghost:hover { background: var(--surface-soft); }
    .brand-icon {
      width: 3rem;
      height: 3rem;
      border-radius: 1.25rem;
      background: var(--surface-soft);
      color: var(--accent-strong);
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
    }
    .checker {
      background-image: linear-gradient(45deg, rgba(148, 163, 184, 0.25) 25%, transparent 25%),
                        linear-gradient(-45deg, rgba(148, 163, 184, 0.25) 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, rgba(148, 163, 184, 0.25) 75%),
                        linear-gradient(-45deg, transparent 75%, rgba(148, 163, 184, 0.25) 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0;
      border-radius: 1rem;
      border: 1px solid var(--border);
    }
    #qrPreview {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 1.25rem;
      padding: 1.25rem;
      width: 100%;
      display: flex;
      justify-content: center;
    }
    #qrPreview canvas, #qrPreview img {
      width: 100%;
      max-width: 360px;
      height: auto;
    }
    .panel-highlight {
      background: var(--surface-soft);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1rem;
    }
    .panel-highlight a { color: var(--accent-strong); }
    .srchighlight { box-shadow: none; }
    .theme-icon {
      display: inline-flex;
      font-size: 1rem;
      line-height: 1;
    }
    .theme-label {
      font-size: 0.9rem;
      font-weight: 500;
    }
    :root[data-theme="light"] .theme-icon-moon { display: none; }
    :root[data-theme="dark"] .theme-icon-sun { display: none; }
    small, .hint { color: var(--muted); }
    footer, #privacy { color: var(--muted); }
    @media (max-width: 640px) {
      .tab-btn { font-size: 0.9rem; }
      #qrPreview { padding: 1rem; }
    }
    #qrPreview canvas, #qrPreview img { width: 100%; height: auto; max-width: min(100%, 420px); display: block; }
    /* Prevent iOS zoom on inputs */
    input, select { font-size: 16px; }
  </style>
  <!-- QR Code Generator (classic) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- QR Scanner -->
  <script src="https://unpkg.com/html5-qrcode"></script>
  <!-- Mediapipe Selfie Segmentation (for person-background removal) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
</head>
<body class="min-h-screen antialiased">
  <header class="container max-w-6xl mx-auto px-4 py-8">
    <div class="flex flex-col gap-6 sm:flex-row sm:items-center sm:justify-between">
      <div class="flex items-center gap-4 justify-center sm:justify-start text-center sm:text-left">
        <div class="brand-icon">QR</div>
        <div>
          <h1 class="text-2xl md:text-3xl font-extrabold tracking-tight leading-tight">All‚Äëin‚ÄëOne QR &amp; Image Toolkit</h1>
          <p class="text-sm text-muted mt-1 hidden sm:block">Generate, scan, and edit on any device.</p>
        </div>
      </div>
      <div class="flex items-center justify-center sm:justify-end gap-3 text-sm text-muted">
        <nav class="flex items-center gap-3">
          <a class="hover:underline" href="#faq">FAQ</a>
          <span aria-hidden="true">‚Ä¢</span>
          <a class="hover:underline" href="#privacy">Privacy</a>
        </nav>
        <button id="themeToggle" type="button" class="btn btn-ghost text-sm" aria-label="Toggle color theme">
          <span class="theme-icon theme-icon-sun" aria-hidden="true">‚òÄÔ∏è</span>
          <span class="theme-icon theme-icon-moon" aria-hidden="true">üåô</span>
          <span class="hidden sm:inline theme-label">Light mode</span>
        </button>
      </div>
    </div>
  </header>

  <main class="container max-w-6xl mx-auto px-4 pb-20">
    <!-- Tabs -->
    <div class="glass p-2 mb-8">
      <div class="grid grid-cols-2 sm:grid-cols-4 gap-2">
        <button data-tab="gen" class="tab-btn tab-active">QR Generator</button>
        <button data-tab="scan" class="tab-btn">QR Scanner</button>
        <button data-tab="bg" class="tab-btn">Background Remover</button>
        <button data-tab="comp" class="tab-btn">Compressor</button>
      </div>
    </div>

    <!-- Panels -->
    <section id="panel-gen" class="panel grid md:grid-cols-2 gap-6 lg:gap-8">
      <div class="glass p-6 space-y-6">
        <h2 class="section-heading">Customize</h2>
        <div class="space-y-4">
          <label class="block">
            <div class="flex items-center justify-between gap-3 text-sm text-muted">
              <span>Content / URL</span>
              <button type="button" id="btnUseCurrentUrl" class="quick-action text-xs sm:text-sm">Use page URL</button>
            </div>
            <textarea id="qrText" class="form-field mt-2 leading-relaxed min-h-[110px] resize-none" rows="3" placeholder="Paste text, a URL, or any message for your QR"></textarea>
          </label>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="grid grid-cols-2 gap-4 md:col-span-2">
              <label class="block">
                <span class="text-sm text-muted">Size</span>
                <input id="qrSize" type="number" min="128" max="1024" value="320" class="form-field mt-1" />
              </label>
              <label class="block">
                <span class="text-sm text-muted">Margin (px)</span>
                <input id="qrMargin" type="number" min="0" max="16" value="2" class="form-field mt-1" />
              </label>
              <label class="block col-span-2">
                <span class="text-sm text-muted">Error Correction</span>
                <select id="qrEC" class="form-field mt-1">
                  <option value="L">L (7%)</option>
                  <option value="M" selected>M (15%)</option>
                  <option value="Q">Q (25%)</option>
                  <option value="H">H (30%)</option>
                </select>
              </label>
            </div>
            <label class="block">
              <span class="text-sm text-muted">Foreground</span>
              <input id="qrFg" type="color" value="#000000" class="form-field mt-1" />
            </label>
            <label class="block">
              <span class="text-sm text-muted">Background</span>
              <input id="qrBg" type="color" value="#ffffff" class="form-field mt-1" />
            </label>
            <label class="block md:col-span-2">
              <span class="text-sm text-muted">Center Logo (optional)</span>
              <input id="qrLogo" type="file" accept="image/*" class="form-field mt-1" />
              <small class="block mt-2 text-xs">Tip: choose H-level error correction when adding logos.</small>
            </label>
          </div>
        </div>
        <div class="flex flex-wrap gap-3">
          <button id="btnGen" class="btn btn-primary flex-1 min-w-[140px]">Generate</button>
          <button id="btnDownloadPNG" class="btn btn-secondary flex-1 min-w-[140px]">Download PNG</button>
          <button id="btnDownloadSVG" class="btn btn-secondary flex-1 min-w-[140px]">Download SVG</button>
        </div>
      </div>
      <div class="glass p-6 flex flex-col items-center justify-center text-center gap-4">
        <h3 class="text-lg font-semibold">Preview</h3>
        <div id="qrPreview" class="w-full max-w-xs sm:max-w-sm">
          <!-- QR renders here -->
        </div>
      </div>
    </section>

    <section id="panel-scan" class="panel hidden grid md:grid-cols-2 gap-6">
      <div class="glass p-6 space-y-4">
        <h2 class="section-heading">Scan with Camera</h2>
        <div id="qr-reader" class="rounded-2xl overflow-hidden"></div>
        <div class="flex flex-wrap items-center gap-3">
          <select id="cameraSelect" class="form-field min-w-[160px] flex-1">
            <option>Loading cameras‚Ä¶</option>
          </select>
          <button id="btnScanStart" class="btn btn-primary">Start</button>
          <button id="btnScanStop" class="btn btn-secondary">Stop</button>
        </div>
        <p class="text-sm text-muted">Permission prompt will appear the first time. Works best in good lighting.</p>
      </div>
      <div class="glass p-6 space-y-4">
        <h2 class="section-heading">Scan from Image</h2>
        <input id="scanFile" type="file" accept="image/*" class="form-field" />
        <div id="scanResult" class="panel-highlight text-sm text-muted min-h-[88px] flex items-center justify-center text-center">Drop a QR image to decode instantly.</div>
      </div>
    </section>

    <section id="panel-bg" class="panel hidden grid md:grid-cols-2 gap-6">
      <div class="glass p-6 space-y-4">
        <h2 class="section-heading">Upload Image</h2>
        <input id="bgFile" type="file" accept="image/*" class="form-field" />
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="text-sm text-muted">Mode</label>
            <select id="bgMode" class="form-field mt-1">
              <option value="auto-person">AI: Person Cutout (on-device)</option>
              <option value="sam-cloud">SAM (cloud)</option>
              <option value="chroma">Chroma‚ÄëKey (solid background)</option>
            </select>
          </div>
          <div id="chromaOptions" class="hidden space-y-3">
            <div>
              <label class="text-sm text-muted">Chroma Color</label>
              <input id="chromaColor" type="color" value="#00ff00" class="form-field mt-1" />
            </div>
            <div>
              <label class="text-sm text-muted">Tolerance</label>
              <input id="chromaTol" type="range" min="5" max="80" value="18" />
            </div>
          </div>
          <div id="personOptions" class="hidden md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="text-sm text-muted flex items-center justify-between">Foreground Confidence <span id="personConfidenceVal" class="text-xs text-muted">55%</span></label>
              <input id="personConfidence" type="range" min="35" max="90" value="55" />
              <p class="text-xs text-muted mt-1">Lower if parts of the subject disappear; raise to clean halos.</p>
            </div>
            <div>
              <label class="text-sm text-muted flex items-center justify-between">Edge Smoothness <span id="personFeatherVal" class="text-xs text-muted">2</span></label>
              <input id="personFeather" type="range" min="0" max="5" value="2" />
              <p class="text-xs text-muted mt-1">Higher values soften edges and close tiny gaps.</p>
            </div>
          </div>
          <div id="personOptions" class="hidden md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label class="text-sm text-slate-300 flex items-center justify-between">Foreground Confidence <span id="personConfidenceVal" class="text-xs text-slate-400">55%</span></label>
              <input id="personConfidence" type="range" min="35" max="90" value="55" class="w-full" />
              <p class="text-xs text-slate-400 mt-1">Lower if parts of the subject disappear; raise to clean halos.</p>
            </div>
            <div>
              <label class="text-sm text-slate-300 flex items-center justify-between">Edge Smoothness <span id="personFeatherVal" class="text-xs text-slate-400">2</span></label>
              <input id="personFeather" type="range" min="0" max="5" value="2" class="w-full" />
              <p class="text-xs text-slate-400 mt-1">Higher values soften edges and close tiny gaps.</p>
            </div>
          </div>
        </div>
        <div class="flex flex-wrap gap-3">
          <button id="btnRemoveBg" class="btn btn-primary flex-1 min-w-[150px]">Remove Background</button>
          <button id="btnDownloadCutout" class="btn btn-secondary flex-1 min-w-[150px]">Download PNG</button>
        </div>
        <p class="text-sm text-muted">Tip: For logos/screenshots with flat colors, try <em>Chroma‚ÄëKey</em>. For portraits, use <em>AI: Person Cutout</em>.</p>
      </div>
      <div class="glass p-6 space-y-4">
        <h2 class="section-heading">Preview</h2>
        <div class="grid grid-cols-1 gap-4">
          <div>
            <h3 class="text-sm text-muted mb-2">Input</h3>
            <div class="checker p-3"><canvas id="inCanvas" class="w-full rounded-xl"></canvas></div>
          </div>
          <div>
            <h3 class="text-sm text-muted mb-2">Cutout</h3>
            <div class="checker p-3"><canvas id="outCanvas" class="w-full rounded-xl"></canvas></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Image Compressor Panel -->
    <section id="panel-comp" class="panel hidden grid md:grid-cols-2 gap-6">
      <div class="glass p-6 space-y-4">
        <h2 class="section-heading">Image Compressor</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <label class="block md:col-span-2">
            <span class="text-sm text-muted">Upload</span>
            <input id="compFile" type="file" accept="image/*" class="form-field mt-1" />
          </label>
          <label class="block">
            <span class="text-sm text-muted">Format</span>
            <select id="compFormat" class="form-field mt-1">
              <option value="auto">Auto (keep type)</option>
              <option value="image/jpeg">JPEG</option>
              <option value="image/webp">WebP</option>
              <option value="image/png">PNG</option>
            </select>
          </label>
          <label class="block">
            <span class="text-sm text-muted">Quality (JPEG/WebP)</span>
            <input id="compQuality" type="range" min="0.4" max="0.95" step="0.05" value="0.8" />
          </label>
          <label class="block">
            <span class="text-sm text-muted">Max Width</span>
            <input id="compMaxW" type="number" min="64" max="8000" value="1920" class="form-field mt-1" />
          </label>
          <label class="block">
            <span class="text-sm text-muted">Max Height</span>
            <input id="compMaxH" type="number" min="64" max="8000" value="1920" class="form-field mt-1" />
          </label>
          <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-3 mt-2">
            <button id="btnCompLocal" class="btn btn-primary">Compress (Local)</button>
            <button id="btnCompTiny" class="btn btn-secondary">Compress with TinyPNG</button>
          </div>
          <div class="md:col-span-2 grid grid-cols-1 md:grid-cols-2 gap-3">
            <label class="block">
              <span class="text-sm text-muted">TinyPNG Proxy URL (serverless)</span>
              <input id="tinyProxy" type="url" placeholder="https://your-proxy.example.com/tinypng" class="form-field mt-1" />
            </label>
            <label class="block">
              <span class="text-sm text-muted">TinyPNG API Key (stored in your proxy)</span>
              <input id="tinyHint" disabled value="Provide via proxy; this field is informational" class="form-field mt-1" />
            </label>
          </div>
        </div>
        <p class="text-sm text-muted">Local compression runs entirely in your browser. TinyPNG requires a small proxy you control to add API credentials and handle CORS.</p>
      </div>
      <div class="glass p-6 space-y-4">
        <h2 class="section-heading">Preview &amp; Stats</h2>
        <div class="grid grid-cols-1 gap-4">
          <div>
            <h3 class="text-sm text-muted mb-2">Original</h3>
            <div class="checker p-3"><img id="compOrigImg" class="w-full rounded-xl" /></div>
            <div id="compOrigMeta" class="text-xs text-muted mt-1"></div>
          </div>
          <div>
            <h3 class="text-sm text-muted mb-2">Compressed</h3>
            <div class="checker p-3"><img id="compOutImg" class="w-full rounded-xl" /></div>
            <div id="compOutMeta" class="text-xs text-muted mt-1"></div>
            <div class="mt-3"><button id="btnCompDownload" class="btn btn-secondary">Download</button></div>
          </div>
        </div>
      </div>
    </section>

    <!--
    <section id="faq" class="mt-10 glass rounded-3xl p-6">
      <h2 class="text-xl font-bold mb-4">Suggestions & Next Features</h2>
      <ul class="list-disc pl-5 space-y-2 text-muted">
        <li>QR types: vCard, Wi‚ÄëFi, Email, SMS, Geo, Calendar, and bulk generation (CSV upload).</li>
        <li>Branding: templates, gradient/eye shapes, logo safe‚Äëzone checker, vector (SVG) export with outlines.</li>
        <li>Short links & analytics: integrate a link shortener with scan analytics (UTM, device, geo).</li>
        <li>Scanner enhancements: barcode formats (EAN/UPC/PDF417), torch toggle, file‚Äëscan batch mode.</li>
        <li>Background remover: add API mode (e.g., remove.bg) for general objects; queue + batch.</li>
        <li>Workspace: project folders, recent items, version history, one‚Äëclick social export sizes.</li>
        <li>Installable PWA: offline QR generator & scanner; camera permissions remembered.</li>
        <li>Auth & billing: free tier limits, credits for BG removals, webhooks, and REST API.</li>
      </ul>
    </section>
    -->

    <section id="privacy" class="mt-6 text-sm text-muted">
      <p><strong>Privacy:</strong> Everything runs locally in your browser. Camera frames are processed on‚Äëdevice. If you later enable an external API for background removal, those images will leave the device per that provider‚Äôs policy.</p>
    </section>
  </main>

  <footer class="container max-w-6xl mx-auto px-4 py-10 text-center text-sm text-muted">
    Built with ‚ù§Ô∏è ‚Äî Frontend‚Äëonly MVP. No server required.
  </footer>

  <script>
    // ---------- Theme
    const root = document.documentElement;
    const themeToggleEl = document.getElementById('themeToggle');
    const themeLabelEl = themeToggleEl ? themeToggleEl.querySelector('.theme-label') : null;

    function setTheme(theme, persist = true) {
      root.dataset.theme = theme;
      if (persist) {
        try { localStorage.setItem('aoi-theme', theme); } catch (err) {}
      }
      if (themeToggleEl && themeLabelEl) {
        themeToggleEl.setAttribute('aria-label', theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme');
        themeLabelEl.textContent = theme === 'dark' ? 'Dark mode' : 'Light mode';
      }
    }

    if (themeToggleEl && themeLabelEl) {
      const storedTheme = (() => { try { return localStorage.getItem('aoi-theme'); } catch (err) { return null; } })();
      const prefersDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : { matches: root.dataset.theme === 'dark' };
      setTheme(root.dataset.theme || storedTheme || (prefersDark.matches ? 'dark' : 'light'), false);

      themeToggleEl.addEventListener('click', () => {
        const next = root.dataset.theme === 'dark' ? 'light' : 'dark';
        setTheme(next);
      });

      const systemHandler = (event) => {
        const manual = (() => { try { return localStorage.getItem('aoi-theme'); } catch (err) { return null; } })();
        if (!manual) {
          setTheme(event.matches ? 'dark' : 'light', false);
        }
      };

      if (typeof prefersDark.addEventListener === 'function') {
        prefersDark.addEventListener('change', systemHandler);
      } else if (typeof prefersDark.addListener === 'function') {
        prefersDark.addListener(systemHandler);
      }
    }

    // ---------- Tabs
    const tabs = document.querySelectorAll('.tab-btn');
    const panels = { gen: document.getElementById('panel-gen'), scan: document.getElementById('panel-scan'), bg: document.getElementById('panel-bg'), comp: document.getElementById('panel-comp') };
    tabs.forEach(btn => btn.addEventListener('click', () => {
      tabs.forEach(b => b.classList.remove('tab-active'));
      btn.classList.add('tab-active');
      const key = btn.dataset.tab;
      Object.entries(panels).forEach(([k, el]) => el.classList.toggle('hidden', k !== key));
    }));

    // ---------- QR GENERATOR
    let qr; const qrDiv = document.getElementById('qrPreview');
    let lastLogoFile = null;
    let lastLogoDataUrl = null;
    let logoRenderToken = 0;

    async function ensureQrLib(){
      // Prefer classic qrcodejs global (QRCode)
      if (window.QRCode) return 'qrcodejs';

      // Helper to load a script tag with fallback
      const loadScript = (src) => new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src; s.async = true; s.crossOrigin = 'anonymous';
        s.onload = () => resolve(true);
        s.onerror = () => reject(new Error('Failed to load ' + src));
        document.head.appendChild(s);
      });

      // Try multiple CDNs for qrcodejs (global QRCode)
      const qrcodejsCDNs = [
        'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js',
        'https://cdn.jsdelivr.net/gh/davidshimjs/qrcodejs/qrcode.min.js',
        'https://unpkg.com/qrcodejs@1.0.0/qrcode.min.js'
      ];
      for (const url of qrcodejsCDNs) {
        try { await loadScript(url); if (window.QRCode) return 'qrcodejs'; } catch(e){ console.warn('CDN fail', url); }
      }

      // Fallback: "qrcode" npm browser bundle (global window.qrcode)
      const qrcodeBundleCDNs = [
        'https://cdn.jsdelivr.net/npm/qrcode@1.5.4/build/qrcode.min.js',
        'https://unpkg.com/qrcode@1.5.4/build/qrcode.min.js'
      ];
      for (const url of qrcodeBundleCDNs) {
        try { await loadScript(url); if (window.qrcode) return 'qrcode-module'; } catch(e){ console.warn('CDN fail', url); }
      }

      throw new Error('No QR library could be loaded (network/CSP?)');
    }

    function debounce(fn, wait = 180) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    async function makeQR() {
      const backend = await ensureQrLib();
      const text = document.getElementById('qrText').value || 'https://example.com';
      const size = parseInt(document.getElementById('qrSize').value, 10) || 320;
      const fg = document.getElementById('qrFg').value || '#000000';
      const bg = document.getElementById('qrBg').value || '#ffffff';
      const ec = (document.getElementById('qrEC').value || 'M');
      const margin = parseInt(document.getElementById('qrMargin').value, 10) || 2;

      qrDiv.innerHTML = '';

      let canvasEl;
      if (backend === 'qrcodejs') {
        // classic qrcodejs path
        qr = new QRCode(qrDiv, {
          text, width: size, height: size,
          colorDark: fg, colorLight: bg,
          correctLevel: QRCode.CorrectLevel[ec] || QRCode.CorrectLevel.M,
        });
        canvasEl = qrDiv.querySelector('canvas') || qrDiv.querySelector('img');
      } else {
        // fallback to qrcode (toCanvas)
        canvasEl = document.createElement('canvas');
        canvasEl.width = size; canvasEl.height = size;
        qrDiv.appendChild(canvasEl);
        await window.qrcode.toCanvas(canvasEl, text, {
          width: size,
          color: { dark: fg, light: bg },
          errorCorrectionLevel: ec
        });
      }

      // Apply margin by wrapping in padding
      qrDiv.style.padding = margin + 'px';

      // Choice 3A ‚Äî Auto-convert <img> ‚Üí <canvas> when a logo is selected,
      // then draw a rounded (A) logo on top.
      if (!canvasEl) return;
      const logoInput = document.getElementById('qrLogo');
      const file = logoInput?.files?.[0];
      const callId = ++logoRenderToken;

      // If the QR output is an <img> and a logo is chosen, convert to canvas first
      if (file && canvasEl.tagName !== 'CANVAS') {
        const imgEl = canvasEl;
        const c = document.createElement('canvas');
        const w = imgEl.naturalWidth || size;
        const h = imgEl.naturalHeight || size;
        c.width = w; c.height = h;
        const ctx0 = c.getContext('2d');
        ctx0.drawImage(imgEl, 0, 0, w, h);
        // Replace DOM so downstream code sees a canvas
        qrDiv.innerHTML = '';
        qrDiv.appendChild(c);
        canvasEl = c;
      }

      if (!file) {
        lastLogoFile = null;
        lastLogoDataUrl = null;
        return;
      }

      const drawLogo = (dataUrl) => {
        const logo = new Image();
        logo.onload = () => {
          if (callId !== logoRenderToken) return;
          if (!canvasEl || canvasEl.tagName !== 'CANVAS') return; // safety
          const ctx = canvasEl.getContext('2d');
          const s = Math.min(canvasEl.width, canvasEl.height);
          const target = Math.floor(s * 0.2); // 20%
          const x = (canvasEl.width - target) / 2;
          const y = (canvasEl.height - target) / 2;
          const r = Math.max(8, Math.floor(target * 0.18));
          ctx.save();
          ctx.fillStyle = '#ffffffcc';
          roundRect(ctx, x - 8, y - 8, target + 16, target + 16, r);
          ctx.fill();
          ctx.restore();
          ctx.drawImage(logo, x, y, target, target);
        };
        logo.src = dataUrl;
      };

      if (file === lastLogoFile && lastLogoDataUrl) {
        drawLogo(lastLogoDataUrl);
      } else {
        const reader = new FileReader();
        reader.onload = () => {
          if (callId !== logoRenderToken) return;
          lastLogoFile = file;
          lastLogoDataUrl = reader.result;
          drawLogo(reader.result);
        };
        reader.onerror = () => console.warn('Logo load failed');
        reader.readAsDataURL(file);
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    const scheduleMakeQR = debounce(() => makeQR(), 180);
    const qrTextArea = document.getElementById('qrText');
    if (qrTextArea) {
      const autoGrow = () => {
        qrTextArea.style.height = 'auto';
        qrTextArea.style.height = Math.min(qrTextArea.scrollHeight, 320) + 'px';
      };
      ['input', 'change'].forEach(evt => qrTextArea.addEventListener(evt, autoGrow));
      qrTextArea.addEventListener('input', scheduleMakeQR);
      autoGrow();
    }

    const useCurrentUrlBtn = document.getElementById('btnUseCurrentUrl');
    if (useCurrentUrlBtn && qrTextArea) {
      useCurrentUrlBtn.addEventListener('click', () => {
        qrTextArea.value = window.location.href;
        qrTextArea.dispatchEvent(new Event('input', { bubbles: true }));
        qrTextArea.focus();
        const end = qrTextArea.value.length;
        qrTextArea.setSelectionRange(end, end);
      });
    }
    ['qrSize', 'qrMargin'].forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('input', scheduleMakeQR);
      el.addEventListener('change', scheduleMakeQR);
    });
    ['qrEC', 'qrFg', 'qrBg'].forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('change', scheduleMakeQR);
      if (el.type === 'color') el.addEventListener('input', scheduleMakeQR);
    });
    document.getElementById('qrLogo').addEventListener('change', () => {
      lastLogoFile = null;
      lastLogoDataUrl = null;
      makeQR();
    });

    document.getElementById('btnGen').addEventListener('click', () => makeQR());
    // initial render (non-blocking)
    makeQR();

    function dataUrlFromCanvasOrImg(el, mime = 'image/png') {
      if (el.tagName === 'CANVAS') return el.toDataURL(mime);
      // if img element, draw into temp canvas
      const cvs = document.createElement('canvas');
      cvs.width = el.width; cvs.height = el.height;
      cvs.getContext('2d').drawImage(el, 0, 0);
      return cvs.toDataURL(mime);
    }

    function svgFromElement(el, size, bg) {
      const data = dataUrlFromCanvasOrImg(el, 'image/png');
      return `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><rect width="100%" height="100%" fill="${bg}"/><image href="${data}" x="0" y="0" width="${size}" height="${size}"/></svg>`;
    }

    function downloadURI(uri, name) {
      const a = document.createElement('a'); a.href = uri; a.download = name; a.click();
    }

    document.getElementById('btnDownloadPNG').addEventListener('click', () => {
      const el = qrDiv.querySelector('canvas') || qrDiv.querySelector('img');
      if (!el) return alert('Generate a QR first.');
      downloadURI(dataUrlFromCanvasOrImg(el, 'image/png'), 'qr.png');
    });

    document.getElementById('btnDownloadSVG').addEventListener('click', async () => {
      // Export current output as PNG-wrapped SVG for compatibility
      let el = qrDiv.querySelector('canvas') || qrDiv.querySelector('img');
      if (!el) await makeQR();
      el = qrDiv.querySelector('canvas') || qrDiv.querySelector('img');
      if (!el) return alert('Generate a QR first.');
      const size = parseInt(document.getElementById('qrSize').value, 10) || 320;
      const bg = document.getElementById('qrBg').value || '#ffffff';
      const svg = svgFromElement(el, size, bg);
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      downloadURI(URL.createObjectURL(blob), 'qr.svg');
    });

    // ---------- QR SCANNER
    let html5QrCode;
    const qrReaderEl = document.getElementById('qr-reader');
    const scanResultEl = document.getElementById('scanResult');
    const cameraSelect = document.getElementById('cameraSelect');
    let availableCameras = [];
    let isScannerRunning = false;
    let loadingCameras = false;

    async function populateCameras(force = false) {
      if (!cameraSelect || loadingCameras) return;
      loadingCameras = true;
      try {
        if (force || !availableCameras.length) {
          availableCameras = await Html5Qrcode.getCameras();
        }
        const prevValue = cameraSelect.value;
        cameraSelect.innerHTML = '';
        if (!availableCameras.length) {
          const opt = document.createElement('option');
          opt.textContent = 'No cameras found';
          cameraSelect.appendChild(opt);
          cameraSelect.disabled = true;
          return;
        }
        availableCameras.forEach((cam, idx) => {
          const opt = document.createElement('option');
          opt.value = cam.id;
          opt.textContent = cam.label || `Camera ${idx + 1}`;
          cameraSelect.appendChild(opt);
        });
        cameraSelect.disabled = false;
        if (prevValue && availableCameras.some(cam => cam.id === prevValue)) {
          cameraSelect.value = prevValue;
        } else if (availableCameras[0]) {
          cameraSelect.value = availableCameras[0].id;
        }
      } catch (err) {
        cameraSelect.innerHTML = '';
        const opt = document.createElement('option');
        opt.textContent = 'Camera access blocked';
        cameraSelect.appendChild(opt);
        cameraSelect.disabled = true;
        console.error('Camera list error', err);
      } finally {
        loadingCameras = false;
      }
    }
    populateCameras();
    cameraSelect?.addEventListener('focus', () => populateCameras(true));

    async function startScanner() {
      try {
        if (!html5QrCode) html5QrCode = new Html5Qrcode('qr-reader');
        if (!availableCameras.length || !cameraSelect?.value) await populateCameras(true);
        const camId = cameraSelect?.value || availableCameras?.[0]?.id;
        if (!camId) throw new Error('No camera found');
        if (isScannerRunning) {
          await html5QrCode.stop();
          isScannerRunning = false;
        }
        await html5QrCode.start(camId, { fps: 10, qrbox: 250 }, onScanSuccess, onScanFailure);
        isScannerRunning = true;
      } catch (e) { alert('Camera error: ' + e.message); }
    }
    function onScanSuccess(decodedText) {
      scanResultEl.classList.remove('items-center', 'justify-center', 'text-center', 'text-muted');
      scanResultEl.classList.add('flex', 'flex-col', 'items-start', 'justify-start', 'gap-2', 'text-left');
      scanResultEl.innerHTML = `<div class="text-xs text-muted uppercase tracking-wide">Result</div><div class="font-mono break-all">${escapeHtml(decodedText)}</div><div class='mt-2'><a class='underline' target='_blank' rel='noopener noreferrer' href='${decodedText}'>Open</a></div>`;
    }
    function onScanFailure() { /* ignore continuous errors */ }
    document.getElementById('btnScanStart').addEventListener('click', startScanner);
    document.getElementById('btnScanStop').addEventListener('click', async () => {
      if (html5QrCode && isScannerRunning) {
        await html5QrCode.stop();
        isScannerRunning = false;
      }
    });
    cameraSelect?.addEventListener('change', async () => {
      if (html5QrCode && isScannerRunning) {
        await html5QrCode.stop();
        isScannerRunning = false;
        startScanner();
      }
    });

    document.getElementById('scanFile').addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      if (!html5QrCode) html5QrCode = new Html5Qrcode('qr-reader');
      const res = await html5QrCode.scanFile(file, true);
      onScanSuccess(res);
    });

    function escapeHtml(str) { return str.replace(/[&<>"]/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

    // ---------- BACKGROUND REMOVAL
    const inC = document.getElementById('inCanvas');
    const outC = document.getElementById('outCanvas');
    const inCtx = inC.getContext('2d');
    const outCtx = outC.getContext('2d');

    const bgModeSel = document.getElementById('bgMode');
    const chromaOptions = document.getElementById('chromaOptions');
    const chromaColor = document.getElementById('chromaColor');
    const chromaTol = document.getElementById('chromaTol');
    const personOptions = document.getElementById('personOptions');
    const personConfidence = document.getElementById('personConfidence');
    const personConfidenceVal = document.getElementById('personConfidenceVal');
    const personFeather = document.getElementById('personFeather');
    const personFeatherVal = document.getElementById('personFeatherVal');

    function syncPersonControls() {
      if (personConfidenceVal) personConfidenceVal.textContent = `${personConfidence.value}%`;
      if (personFeatherVal) personFeatherVal.textContent = personFeather.value;
    }

    bgModeSel.addEventListener('change', () => {
      chromaOptions.classList.toggle('hidden', bgModeSel.value !== 'chroma');
      personOptions.classList.toggle('hidden', bgModeSel.value !== 'auto-person');
      if (bgModeSel.value === 'auto-person') {
        syncPersonControls();
        if (sourceImg) applyPersonMask();
      }
    });
    syncPersonControls();

    let sourceImg;
    let basePersonMask = null;
    let baseMaskW = 0;
    let baseMaskH = 0;
    let selfieInstance;
    let segInFlight = false;
    const segTmpCanvas = document.createElement('canvas');
    const segTmpCtx = segTmpCanvas.getContext('2d');
    const personMaskCanvas = document.createElement('canvas');
    const personMaskCtx = personMaskCanvas.getContext('2d');
    document.getElementById('bgFile').addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          sourceImg = img;
          drawInput(img);
          basePersonMask = null;
          baseMaskW = baseMaskH = 0;
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(f);
    });

    personConfidence?.addEventListener('input', () => {
      syncPersonControls();
      applyPersonMask();
    });
    personFeather?.addEventListener('input', () => {
      syncPersonControls();
      applyPersonMask();
    });

    function drawInput(img) {
      const maxW = 900, maxH = 600;
      let { width:w, height:h } = img;
      const ratio = Math.min(maxW / w, maxH / h, 1);
      w = Math.round(w * ratio); h = Math.round(h * ratio);
      inC.width = outC.width = w; inC.height = outC.height = h;
      inCtx.clearRect(0,0,w,h); outCtx.clearRect(0,0,w,h);
      inCtx.drawImage(img, 0, 0, w, h);
    }

    async function removeBackground() {
      if (!sourceImg) return alert('Upload an image first.');
      setBgStatus('');
      if (bgModeSel.value === 'chroma') {
        chromaKey();
      } else if (bgModeSel.value === 'sam-cloud') {
        await samCutout();
      } else {
        await personCutout(true);
      }
    }

    document.getElementById('btnRemoveBg').addEventListener('click', removeBackground);

    async function samCutout() {
      const w = inC.width, h = inC.height;
      if (!w || !h) return;
      try {
        setBgLoading(true, 'Contacting SAM‚Ä¶');
        setBgStatus('Contacting SAM (cloud)‚Ä¶');
        const payload = inC.toDataURL('image/png');
        const resp = await fetch('/api/sam', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ image: payload }),
        });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(txt || `SAM request failed (${resp.status})`);
        }
        const blob = await resp.blob();
        const maskImg = await blobToImage(blob);
        outCtx.clearRect(0, 0, w, h);
        outCtx.drawImage(inC, 0, 0, w, h);
        outCtx.globalCompositeOperation = 'destination-in';
        outCtx.drawImage(maskImg, 0, 0, w, h);
        outCtx.globalCompositeOperation = 'source-over';
        setBgStatus('SAM cutout complete.', 'success');
      } catch (err) {
        console.error('SAM cutout failed', err);
        setBgStatus(`SAM (cloud) unavailable: ${err.message || err}. Falling back to on-device cutout.`, 'error');
        suppressStatusClear = true;
        bgModeSel.value = 'auto-person';
        bgModeSel.dispatchEvent(new Event('change'));
        suppressStatusClear = false;
        await personCutout(true);
      } finally {
        setBgLoading(false);
      }
    }

    document.getElementById('btnDownloadCutout').addEventListener('click', () => {
      if (!outC.width) return alert('No cutout to download.');
      outC.toBlob(b => { const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'cutout.png'; a.click(); }, 'image/png');
    });

    function chromaKey() {
      const w = inC.width, h = inC.height;
      if (!w || !h) return;
      const src = inCtx.getImageData(0,0,w,h);
      const dst = outCtx.createImageData(w,h);
      const [rT,gT,bT] = hexToRgb(chromaColor.value);
      const tol = parseInt(chromaTol.value,10);
      const softness = Math.max(12, tol * 1.35);
      const alphaMask = new Float32Array(w*h);
      for (let i=0,j=0;i<src.data.length;i+=4,j++){
        const r=src.data[i], g=src.data[i+1], b=src.data[i+2], a=src.data[i+3];
        const dist = Math.sqrt((r-rT)**2 + (g-gT)**2 + (b-bT)**2);
        let alpha = (dist - tol) / softness;
        alpha = Math.max(0, Math.min(1, alpha));
        alphaMask[j] = alpha * (a / 255);
        dst.data[i] = r; dst.data[i+1] = g; dst.data[i+2] = b;
      }
      const smoothPasses = Math.max(0, Math.round(tol / 25));
      if (smoothPasses > 0) smoothAlpha(alphaMask, w, h, smoothPasses);
      for (let i=0,j=0;i<dst.data.length;i+=4,j++){
        dst.data[i+3] = Math.round(alphaMask[j] * 255);
      }
      outCtx.putImageData(dst,0,0);
    }

    function smoothAlpha(alpha, width, height, iterations = 1) {
      if (!iterations) return alpha;
      const tmp = new Float32Array(alpha.length);
      for (let iter = 0; iter < iterations; iter++) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            let sum = 0;
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
              const ny = y + dy;
              if (ny < 0 || ny >= height) continue;
              for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx;
                if (nx < 0 || nx >= width) continue;
                sum += alpha[ny * width + nx];
                count++;
              }
            }
            tmp[y * width + x] = count ? sum / count : alpha[y * width + x];
          }
        }
        alpha.set(tmp);
      }
      return alpha;
    }

    function applyPersonMask() {
      if (!basePersonMask || !baseMaskW || !baseMaskH) {
        if (!segInFlight && sourceImg && bgModeSel.value === 'auto-person') personCutout(true);
        return;
      }
      const w = baseMaskW;
      const h = baseMaskH;
      const threshold = (parseInt(personConfidence?.value || '55', 10) || 55) / 100;
      const featherPasses = parseInt(personFeather?.value || '0', 10) || 0;
      const working = basePersonMask.slice();
      const denom = Math.max(0.0001, 1 - threshold);
      for (let i = 0; i < working.length; i++) {
        let val = (working[i] - threshold) / denom;
        working[i] = Math.min(1, Math.max(0, val));
      }
      if (featherPasses > 0) smoothAlpha(working, w, h, featherPasses * 2);

      personMaskCanvas.width = w;
      personMaskCanvas.height = h;
      const maskData = personMaskCtx.createImageData(w, h);
      for (let i = 0, j = 0; i < maskData.data.length; i += 4, j++) {
        const alpha = Math.round(working[j] * 255);
        maskData.data[i] = 255;
        maskData.data[i + 1] = 255;
        maskData.data[i + 2] = 255;
        maskData.data[i + 3] = alpha;
      }
      personMaskCtx.putImageData(maskData, 0, 0);

      outCtx.clearRect(0, 0, w, h);
      outCtx.drawImage(inC, 0, 0, w, h);
      outCtx.globalCompositeOperation = 'destination-in';
      outCtx.drawImage(personMaskCanvas, 0, 0, w, h);
      outCtx.globalCompositeOperation = 'source-over';
    }

    async function personCutout(forceRefresh = true) {
      if (!sourceImg) return;
      const w = inC.width, h = inC.height;
      if (!w || !h) return;
      if (!forceRefresh && basePersonMask && baseMaskW === w && baseMaskH === h) {
        applyPersonMask();
        return;
      }
      if (segInFlight) return;
      if (!selfieInstance) {
        selfieInstance = new SelfieSegmentation({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}` });
        selfieInstance.setOptions({ modelSelection: 1 });
      }
      segInFlight = true;
      await new Promise((resolve) => {
        let settled = false;
        const finish = () => {
          if (settled) return;
          settled = true;
          segInFlight = false;
          resolve();
        };
        selfieInstance.onResults((res) => {
          try {
            segTmpCanvas.width = w;
            segTmpCanvas.height = h;
            segTmpCtx.clearRect(0, 0, w, h);
            segTmpCtx.drawImage(res.segmentationMask, 0, 0, w, h);
            const data = segTmpCtx.getImageData(0, 0, w, h).data;
            basePersonMask = new Float32Array(w * h);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
              basePersonMask[j] = data[i] / 255;
            }
            baseMaskW = w;
            baseMaskH = h;
            applyPersonMask();
          } finally {
            finish();
          }
        });
        const img = new Image();
        img.onload = () => {
          selfieInstance.send({ image: img }).catch((err) => {
            console.error('SelfieSegmentation send failed', err);
            finish();
          });
        };
        img.onerror = (err) => {
          console.error('Segmentation image load failed', err);
          finish();
        };
        img.src = inC.toDataURL('image/png');
      });
    }

    function hexToRgb(hex){
      const v = hex.replace('#','');
      const bigint = parseInt(v,16);
      return v.length===3
        ? [ (bigint>>8&0xF)*17, (bigint>>4&0xF)*17, (bigint&0xF)*17 ]
        : [ bigint>>16 & 255, bigint>>8 & 255, bigint & 255 ];
    }

    // ---------- Minimal Self Tests (console) ----------
    async function runSelfTests(){
      const results = [];
      try {
        const backend = await ensureQrLib();
        results.push(['lib-loaded', backend === 'qrcodejs' || backend === 'qrcode-module']);
        // Test 1: basic QR render
        if (qrTextArea) {
          qrTextArea.value = 'test://qr';
          qrTextArea.dispatchEvent(new Event('input', { bubbles: true }));
        }
        await makeQR();
        let el = qrDiv.querySelector('canvas') || qrDiv.querySelector('img');
        results.push(['qr-rendered', !!el]);
        // Test 2: PNG data URL
        const png = el ? dataUrlFromCanvasOrImg(el) : '';
        results.push(['png-dataurl', typeof png === 'string' && png.startsWith('data:image/png')]);
        // Test 3: size change respected
        document.getElementById('qrSize').value = '256';
        await makeQR();
        el = qrDiv.querySelector('canvas') || qrDiv.querySelector('img');
        const w = el && el.width ? el.width : (el && el.naturalWidth);
        results.push(['size-256', w === 256]);
        // Test 4: SVG string build
        const svg = el ? svgFromElement(el, 128, '#ffffff') : '';
        results.push(['svg-string', typeof svg === 'string' && svg.includes('<svg')]);
      } catch (e) {
        console.error('Self tests error', e);
        results.push(['exception', false]);
      }
      console.table(results.map(([k, v]) => ({ test: k, pass: !!v })));
    }
    // Run once after initial paint
    setTimeout(runSelfTests, 300);

    // ---------- IMAGE COMPRESSION (Local + TinyPNG via proxy)
    const compFile = document.getElementById('compFile');
    const compFormatSel = document.getElementById('compFormat');
    const compQuality = document.getElementById('compQuality');
    const compMaxW = document.getElementById('compMaxW');
    const compMaxH = document.getElementById('compMaxH');
    const compOrigImg = document.getElementById('compOrigImg');
    const compOutImg = document.getElementById('compOutImg');
    const compOrigMeta = document.getElementById('compOrigMeta');
    const compOutMeta = document.getElementById('compOutMeta');
    const btnCompLocal = document.getElementById('btnCompLocal');
    const btnCompTiny = document.getElementById('btnCompTiny');
    const btnCompDownload = document.getElementById('btnCompDownload');
    const tinyProxy = document.getElementById('tinyProxy');

    let lastCompressedBlob;

    compFile?.addEventListener('change', () => {
      const f = compFile.files?.[0]; if (!f) return;
      const url = URL.createObjectURL(f);
      compOrigImg.src = url;
      compOrigMeta.textContent = `${f.type} ‚Ä¢ ${(f.size/1024).toFixed(1)} KB`;
    });

    btnCompLocal?.addEventListener('click', async () => {
      const f = compFile.files?.[0]; if (!f) return alert('Upload an image first.');
      const img = await blobToImage(f);
      const maxW = parseInt(compMaxW.value,10)||1920;
      const maxH = parseInt(compMaxH.value,10)||1920;
      const {canvas,w,h} = drawToFit(img, maxW, maxH);
      let mime = compFormatSel.value==='auto' ? f.type || 'image/jpeg' : compFormatSel.value;
      // Browsers may not support requested mime; fallback logic
      if (!/image\/(png|jpeg|webp)/.test(mime)) mime = 'image/jpeg';
      const quality = parseFloat(compQuality.value)||0.8;
      const blob = await canvasToBlob(canvas, mime, quality);
      lastCompressedBlob = blob;
      const url = URL.createObjectURL(blob);
      compOutImg.src = url;
      compOutMeta.textContent = `${mime} ‚Ä¢ ${(blob.size/1024).toFixed(1)} KB ‚Ä¢ ${(100 - (blob.size/f.size*100)).toFixed(1)}% saved`;
    });

    btnCompTiny?.addEventListener('click', async () => {
      const f = compFile.files?.[0]; if (!f) return alert('Upload an image first.');
      const proxy = tinyProxy.value.trim();
      if (!proxy) return alert('Enter your TinyPNG proxy URL first.');
      try{
        const fd = new FormData();
        fd.append('file', f, f.name);
        const resp = await fetch(proxy, { method: 'POST', body: fd });
        if (!resp.ok) throw new Error('Proxy error: '+resp.status);
        const blob = await resp.blob();
        lastCompressedBlob = blob;
        const url = URL.createObjectURL(blob);
        compOutImg.src = url;
        compOutMeta.textContent = `${blob.type||'image/png'} ‚Ä¢ ${(blob.size/1024).toFixed(1)} KB ‚Ä¢ ${(100 - (blob.size/f.size*100)).toFixed(1)}% saved (TinyPNG)`;
      } catch(e){ alert('TinyPNG proxy request failed: '+e.message); }
    });

    btnCompDownload?.addEventListener('click', () => {
      if (!lastCompressedBlob) return alert('No compressed image yet.');
      const a = document.createElement('a');
      a.href = URL.createObjectURL(lastCompressedBlob);
      a.download = 'compressed';
      a.click();
    });

    function drawToFit(img, maxW, maxH){
      let w = img.naturalWidth, h = img.naturalHeight;
      const ratio = Math.min(maxW / w, maxH / h, 1);
      w = Math.round(w*ratio); h = Math.round(h*ratio);
      const canvas = document.createElement('canvas'); canvas.width=w; canvas.height=h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);
      return {canvas,w,h};
    }
    function canvasToBlob(canvas, mime, quality){
      return new Promise(res => canvas.toBlob(b => res(b), mime, quality));
    }
    function blobToImage(blob){
      return new Promise(res => { const img = new Image(); img.onload=()=>res(img); img.src = URL.createObjectURL(blob); });
    }

    // ----- Self-tests for compressor (console only)
    async function compressorSelfTests(){
      const results=[];
      try{
        // create tiny test canvas
        const c=document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d'); ctx.fillStyle='#0af'; ctx.fillRect(0,0,64,64);
        const blob=await canvasToBlob(c,'image/png');
        const img=await blobToImage(blob);
        const {canvas}=drawToFit(img,32,32);
        const out=await canvasToBlob(canvas,'image/jpeg',0.8);
        results.push(['local-compress', out.size>0 && out.size<=blob.size]);
      }catch(e){ results.push(['exception', false]); console.error(e); }
      console.table(results.map(([k,v])=>({test:k, pass:!!v})));
    }
    setTimeout(compressorSelfTests, 600);
  </script>
</body>
</html>
